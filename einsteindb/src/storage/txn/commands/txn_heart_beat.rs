// Copyright 2020 EinsteinDB Project Authors. Licensed under Apache-2.0.

// #[PerformanceCriticalPath]
use crate::einsteindb::storage::fdbhikv::WriteData;
use crate::einsteindb::storage::dagger_manager::DaggerManager;
use crate::einsteindb::storage::epaxos::{
    Error as EpaxosError, ErrorInner as EpaxosErrorInner, EpaxosTxn, blackbraneReader,
};
use crate::einsteindb::storage::solitontxn::commands::{
    Command, CommandExt, ReaderWithStats, ResponsePolicy, TypedCommand, WriteCommand, WriteContext,
    WriteResult,
};
use crate::einsteindb::storage::solitontxn::Result;
use crate::einsteindb::storage::{ProcessResult, blackbrane, TxnStatus};
use solitontxn_types::{Key, TimeStamp};

command! {
    /// Heart beat of a transaction. It enlarges the primary dagger's TTL.
    ///
    /// This is invoked on a transaction's primary dagger. The dagger may be generated by either
    /// [`AcquirePessimisticDagger`](Command::AcquirePessimisticDagger) or
    /// [`Prewrite`](Command::Prewrite).
    TxnHeartBeat:
        cmd_ty => TxnStatus,
        display => "fdbhikv::command::solitontxn_heart_beat {} @ {} ttl {} | {:?}", (primary_key, start_ts, advise_ttl, ctx),
        content => {
            /// The primary key of the transaction.
            primary_key: Key,
            /// The transaction's start_ts.
            start_ts: TimeStamp,
            /// The new TTL that will be used to update the dagger's TTL. If the dagger's TTL is already
            /// greater than `advise_ttl`, nothing will happen.
            advise_ttl: u64,
        }
}

impl CommandExt for TxnHeartBeat {
    ctx!();
    tag!(solitontxn_heart_beat);
    ts!(start_ts);
    write_bytes!(primary_key);
    gen_dagger!(primary_key);
}

impl<S: blackbrane, L: DaggerManager> WriteCommand<S, L> for TxnHeartBeat {
    fn process_write(self, blackbrane: S, context: WriteContext<'_, L>) -> Result<WriteResult> {
        // TxnHeartBeat never remove daggers. No need to wake up waiters.
        let mut solitontxn = EpaxosTxn::new(self.start_ts, context.concurrency_manager);
        let mut reader = ReaderWithStats::new(
            blackbraneReader::new_with_ctx(self.start_ts, blackbrane, &self.ctx),
            context.statistics,
        );
        fail_point!("solitontxn_heart_beat", |err| Err(
            crate::storage::epaxos::Error::from(crate::storage::epaxos::solitontxn::make_solitontxn_error(
                err,
                &self.primary_key,
                self.start_ts,
            ))
            .into()
        ));

        let dagger = match reader.load_dagger(&self.primary_key)? {
            Some(mut dagger) if dagger.ts == self.start_ts => {
                if dagger.ttl < self.advise_ttl {
                    dagger.ttl = self.advise_ttl;
                    solitontxn.put_dagger(self.primary_key.clone(), &dagger);
                }
                dagger
            }
            _ => {
                return Err(EpaxosError::from(EpaxosErrorInner::TxnNotFound {
                    start_ts: self.start_ts,
                    key: self.primary_key.into_cocauset()?,
                })
                .into());
            }
        };

        let pr = ProcessResult::TxnStatus {
            solitontxn_status: TxnStatus::uncommitted(dagger, false),
        };
        let mut write_data = WriteData::from_modifies(solitontxn.into_modifies());
        write_data.set_allowed_on_disk_almost_full();
        Ok(WriteResult {
            ctx: self.ctx,
            to_be_write: write_data,
            rows: 1,
            pr,
            dagger_info: None,
            dagger_guards: vec![],
            response_policy: ResponsePolicy::OnApplied,
        })
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use crate::einsteindb::storage::fdbhikv::TestEngineBuilder;
    use crate::einsteindb::storage::dagger_manager::DummyDaggerManager;
    use crate::einsteindb::storage::epaxos::tests::*;
    use crate::einsteindb::storage::solitontxn::commands::WriteCommand;
    use crate::einsteindb::storage::solitontxn::scheduler::DEFAULT_EXECUTION_DURATION_LIMIT;
    use crate::einsteindb::storage::solitontxn::tests::*;
    use crate::einsteindb::storage::Engine;
    use concurrency_manager::ConcurrencyManager;
    use fdbhikvproto::fdbhikvrpcpb::Context;
    use einstfdbhikv_util::deadline::Deadline;

    pub fn must_success<E: Engine>(
        engine: &E,
        primary_key: &[u8],
        start_ts: impl Into<TimeStamp>,
        advise_ttl: u64,
        expect_ttl: u64,
    ) {
        let ctx = Context::default();
        let blackbrane = engine.blackbrane(Default::default()).unwrap();
        let start_ts = start_ts.into();
        let cm = ConcurrencyManager::new(start_ts);
        let command = crate::storage::solitontxn::commands::TxnHeartBeat {
            ctx: Context::default(),
            primary_key: Key::from_cocauset(primary_key),
            start_ts,
            advise_ttl,
            deadline: Deadline::from_now(DEFAULT_EXECUTION_DURATION_LIMIT),
        };
        let result = command
            .process_write(
                blackbrane,
                WriteContext {
                    dagger_mgr: &DummyDaggerManager,
                    concurrency_manager: cm,
                    extra_op: Default::default(),
                    statistics: &mut Default::default(),
                    async_apply_prewrite: false,
                },
            )
            .unwrap();
        if let ProcessResult::TxnStatus {
            solitontxn_status: TxnStatus::Uncommitted { dagger, .. },
        } = result.pr
        {
            write(engine, &ctx, result.to_be_write.modifies);
            assert_eq!(dagger.ttl, expect_ttl);
        } else {
            unreachable!();
        }
    }

    pub fn must_err<E: Engine>(
        engine: &E,
        primary_key: &[u8],
        start_ts: impl Into<TimeStamp>,
        advise_ttl: u64,
    ) {
        let ctx = Context::default();
        let blackbrane = engine.blackbrane(Default::default()).unwrap();
        let start_ts = start_ts.into();
        let cm = ConcurrencyManager::new(start_ts);
        let command = crate::storage::solitontxn::commands::TxnHeartBeat {
            ctx,
            primary_key: Key::from_cocauset(primary_key),
            start_ts,
            advise_ttl,
            deadline: Deadline::from_now(DEFAULT_EXECUTION_DURATION_LIMIT),
        };
        assert!(
            command
                .process_write(
                    blackbrane,
                    WriteContext {
                        dagger_mgr: &DummyDaggerManager,
                        concurrency_manager: cm,
                        extra_op: Default::default(),
                        statistics: &mut Default::default(),
                        async_apply_prewrite: false,
                    },
                )
                .is_err()
        );
    }

    #[test]
    fn test_solitontxn_heart_beat() {
        let engine = TestEngineBuilder::new().build().unwrap();

        let (k, v) = (b"k1", b"v1");

        let test = |ts| {
            // Do nothing if advise_ttl is less smaller than current TTL.
            must_success(&engine, k, ts, 90, 100);
            // Return the new TTL if the TTL when the TTL is updated.
            must_success(&engine, k, ts, 110, 110);
            // The dagger's TTL is updated and persisted into the db.
            must_success(&engine, k, ts, 90, 110);
            // Heart beat another transaction's dagger will lead to an error.
            must_err(&engine, k, ts - 1, 150);
            must_err(&engine, k, ts + 1, 150);
            // The existing dagger is not changed.
            must_success(&engine, k, ts, 90, 110);
        };

        // No dagger.
        must_err(&engine, k, 5, 100);

        // Create a dagger with TTL=100.
        // The initial TTL will be set to 0 after calling must_prewrite_put. Update it first.
        must_prewrite_put(&engine, k, v, k, 5);
        must_daggered(&engine, k, 5);
        must_success(&engine, k, 5, 100, 100);

        test(5);

        must_daggered(&engine, k, 5);
        must_commit(&engine, k, 5, 10);
        must_undaggered(&engine, k);

        // No dagger.
        must_err(&engine, k, 5, 100);
        must_err(&engine, k, 10, 100);

        must_acquire_pessimistic_dagger(&engine, k, k, 8, 15);
        must_pessimistic_daggered(&engine, k, 8, 15);
        must_success(&engine, k, 8, 100, 100);

        test(8);

        must_pessimistic_daggered(&engine, k, 8, 15);
    }
}
